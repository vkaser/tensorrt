<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TensorRT: nvinfer1::ITensor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TensorRT
   &#160;<span id="projectnumber">6.0.1.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classnvinfer1_1_1_i_tensor.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnvinfer1_1_1_i_tensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nvinfer1::ITensor Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A tensor in a network definition.  
 <a href="classnvinfer1_1_1_i_tensor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_nv_infer_8h_source.html">NvInfer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a58c30f3df7fc07bac9d9922af30f973a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a58c30f3df7fc07bac9d9922af30f973a">setName</a> (const char *name)=0</td></tr>
<tr class="memdesc:a58c30f3df7fc07bac9d9922af30f973a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the tensor name.  <a href="#a58c30f3df7fc07bac9d9922af30f973a">More...</a><br /></td></tr>
<tr class="separator:a58c30f3df7fc07bac9d9922af30f973a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d22afa3925a216cef93191211fdb1c"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a13d22afa3925a216cef93191211fdb1c">getName</a> () const =0</td></tr>
<tr class="memdesc:a13d22afa3925a216cef93191211fdb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tensor name.  <a href="#a13d22afa3925a216cef93191211fdb1c">More...</a><br /></td></tr>
<tr class="separator:a13d22afa3925a216cef93191211fdb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9252b2955e41bd77859c7d610778cbfa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a9252b2955e41bd77859c7d610778cbfa">setDimensions</a> (<a class="el" href="classnvinfer1_1_1_dims.html">Dims</a> dimensions)=0</td></tr>
<tr class="memdesc:a9252b2955e41bd77859c7d610778cbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the dimensions of a tensor.  <a href="#a9252b2955e41bd77859c7d610778cbfa">More...</a><br /></td></tr>
<tr class="separator:a9252b2955e41bd77859c7d610778cbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f05f9eb1b9426b3d70eb646ae18961c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnvinfer1_1_1_dims.html">Dims</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a9f05f9eb1b9426b3d70eb646ae18961c">getDimensions</a> () const =0</td></tr>
<tr class="memdesc:a9f05f9eb1b9426b3d70eb646ae18961c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimensions of a tensor.  <a href="#a9f05f9eb1b9426b3d70eb646ae18961c">More...</a><br /></td></tr>
<tr class="separator:a9f05f9eb1b9426b3d70eb646ae18961c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1004b03f9249097f6d146abc3772819a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a1004b03f9249097f6d146abc3772819a">setType</a> (<a class="el" href="namespacenvinfer1.html#afec8200293dc7ed40aca48a763592217">DataType</a> type)=0</td></tr>
<tr class="memdesc:a1004b03f9249097f6d146abc3772819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data type of a tensor.  <a href="#a1004b03f9249097f6d146abc3772819a">More...</a><br /></td></tr>
<tr class="separator:a1004b03f9249097f6d146abc3772819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab873fe0fe824d178b4c53cb725c1e934"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacenvinfer1.html#afec8200293dc7ed40aca48a763592217">DataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#ab873fe0fe824d178b4c53cb725c1e934">getType</a> () const =0</td></tr>
<tr class="memdesc:ab873fe0fe824d178b4c53cb725c1e934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data type of a tensor.  <a href="#ab873fe0fe824d178b4c53cb725c1e934">More...</a><br /></td></tr>
<tr class="separator:ab873fe0fe824d178b4c53cb725c1e934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956f662b1d2ebe7ba3aba3391aedddf5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a956f662b1d2ebe7ba3aba3391aedddf5">setDynamicRange</a> (float min, float max)=0</td></tr>
<tr class="memdesc:a956f662b1d2ebe7ba3aba3391aedddf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set dynamic range for the tensor.  <a href="#a956f662b1d2ebe7ba3aba3391aedddf5">More...</a><br /></td></tr>
<tr class="separator:a956f662b1d2ebe7ba3aba3391aedddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5137316c30baaba635321e34b8da366e"><td class="memItemLeft" align="right" valign="top">virtual TRT_DEPRECATED float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a5137316c30baaba635321e34b8da366e">getDynamicRange</a> () const =0</td></tr>
<tr class="memdesc:a5137316c30baaba635321e34b8da366e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get dynamic range for the tensor.  <a href="#a5137316c30baaba635321e34b8da366e">More...</a><br /></td></tr>
<tr class="separator:a5137316c30baaba635321e34b8da366e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85366d5b89edcfb5406642fe0361773b"><td class="memItemLeft" align="right" valign="top"><a id="a85366d5b89edcfb5406642fe0361773b"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a85366d5b89edcfb5406642fe0361773b">isNetworkInput</a> () const =0</td></tr>
<tr class="memdesc:a85366d5b89edcfb5406642fe0361773b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the tensor is a network input. <br /></td></tr>
<tr class="separator:a85366d5b89edcfb5406642fe0361773b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3054c068c6fae603f2767006f8937255"><td class="memItemLeft" align="right" valign="top"><a id="a3054c068c6fae603f2767006f8937255"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a3054c068c6fae603f2767006f8937255">isNetworkOutput</a> () const =0</td></tr>
<tr class="memdesc:a3054c068c6fae603f2767006f8937255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the tensor is a network output. <br /></td></tr>
<tr class="separator:a3054c068c6fae603f2767006f8937255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16776768ec263d07005aaa8b7162895"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#ae16776768ec263d07005aaa8b7162895">setBroadcastAcrossBatch</a> (bool broadcastAcrossBatch)=0</td></tr>
<tr class="memdesc:ae16776768ec263d07005aaa8b7162895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether to enable broadcast of tensor across the batch.  <a href="#ae16776768ec263d07005aaa8b7162895">More...</a><br /></td></tr>
<tr class="separator:ae16776768ec263d07005aaa8b7162895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bbf910040e8aeb678da5983edf5021"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a48bbf910040e8aeb678da5983edf5021">getBroadcastAcrossBatch</a> () const =0</td></tr>
<tr class="memdesc:a48bbf910040e8aeb678da5983edf5021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if tensor is broadcast across the batch.  <a href="#a48bbf910040e8aeb678da5983edf5021">More...</a><br /></td></tr>
<tr class="separator:a48bbf910040e8aeb678da5983edf5021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2f24dc64a979f54484e42066e648a5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacenvinfer1.html#aa309b24544789919417899b4d9c504cf">TensorLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a0f2f24dc64a979f54484e42066e648a5">getLocation</a> () const =0</td></tr>
<tr class="memdesc:a0f2f24dc64a979f54484e42066e648a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the storage location of a tensor.  <a href="#a0f2f24dc64a979f54484e42066e648a5">More...</a><br /></td></tr>
<tr class="separator:a0f2f24dc64a979f54484e42066e648a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e38c546bf5d33d82096210791b53d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a50e38c546bf5d33d82096210791b53d8">setLocation</a> (<a class="el" href="namespacenvinfer1.html#aa309b24544789919417899b4d9c504cf">TensorLocation</a> location)=0</td></tr>
<tr class="memdesc:a50e38c546bf5d33d82096210791b53d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the storage location of a tensor.  <a href="#a50e38c546bf5d33d82096210791b53d8">More...</a><br /></td></tr>
<tr class="separator:a50e38c546bf5d33d82096210791b53d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78eb0840f4dcbf05ad40dd82706decf6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a78eb0840f4dcbf05ad40dd82706decf6">dynamicRangeIsSet</a> () const =0</td></tr>
<tr class="memdesc:a78eb0840f4dcbf05ad40dd82706decf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether dynamic range is set.  <a href="#a78eb0840f4dcbf05ad40dd82706decf6">More...</a><br /></td></tr>
<tr class="separator:a78eb0840f4dcbf05ad40dd82706decf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cae811ed6471d916c9ceeb622ef0692"><td class="memItemLeft" align="right" valign="top"><a id="a5cae811ed6471d916c9ceeb622ef0692"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a5cae811ed6471d916c9ceeb622ef0692">resetDynamicRange</a> ()=0</td></tr>
<tr class="memdesc:a5cae811ed6471d916c9ceeb622ef0692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo effect of setDynamicRange. <br /></td></tr>
<tr class="separator:a5cae811ed6471d916c9ceeb622ef0692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07033c8d4b395aeedbc30d370629d179"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a07033c8d4b395aeedbc30d370629d179">getDynamicRangeMin</a> () const =0</td></tr>
<tr class="memdesc:a07033c8d4b395aeedbc30d370629d179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum of dynamic range.  <a href="#a07033c8d4b395aeedbc30d370629d179">More...</a><br /></td></tr>
<tr class="separator:a07033c8d4b395aeedbc30d370629d179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07cd864b3bc5570cb97a0272eee7685"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#ad07cd864b3bc5570cb97a0272eee7685">getDynamicRangeMax</a> () const =0</td></tr>
<tr class="memdesc:ad07cd864b3bc5570cb97a0272eee7685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum of dynamic range.  <a href="#ad07cd864b3bc5570cb97a0272eee7685">More...</a><br /></td></tr>
<tr class="separator:ad07cd864b3bc5570cb97a0272eee7685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6a8ccb84e2e4547371e10574a5bfb4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#abb6a8ccb84e2e4547371e10574a5bfb4">setAllowedFormats</a> (<a class="el" href="namespacenvinfer1.html#ac930bc5598e6612b719019d2e7bf2eb0">TensorFormats</a> formats)=0</td></tr>
<tr class="memdesc:abb6a8ccb84e2e4547371e10574a5bfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set allowed formats for this tensor. By default all formats are allowed. Shape tensors (for which <a class="el" href="classnvinfer1_1_1_i_tensor.html#a7ebdf9179a63a07d1b9c0c6e9aa91a1d" title="Whether the tensor is a shape tensor. ">isShapeTensor()</a> returns true) may only have row major linear format.  <a href="#abb6a8ccb84e2e4547371e10574a5bfb4">More...</a><br /></td></tr>
<tr class="separator:abb6a8ccb84e2e4547371e10574a5bfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b9b7f16322cf6dbd139f37cbe053a4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacenvinfer1.html#ac930bc5598e6612b719019d2e7bf2eb0">TensorFormats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a83b9b7f16322cf6dbd139f37cbe053a4">getAllowedFormats</a> () const =0</td></tr>
<tr class="memdesc:a83b9b7f16322cf6dbd139f37cbe053a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a bitmask of TensorFormat values that the tensor supports. For a shape tensor, only row major linear format is allowed.  <a href="#a83b9b7f16322cf6dbd139f37cbe053a4">More...</a><br /></td></tr>
<tr class="separator:a83b9b7f16322cf6dbd139f37cbe053a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebdf9179a63a07d1b9c0c6e9aa91a1d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#a7ebdf9179a63a07d1b9c0c6e9aa91a1d">isShapeTensor</a> () const =0</td></tr>
<tr class="memdesc:a7ebdf9179a63a07d1b9c0c6e9aa91a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the tensor is a shape tensor.  <a href="#a7ebdf9179a63a07d1b9c0c6e9aa91a1d">More...</a><br /></td></tr>
<tr class="separator:a7ebdf9179a63a07d1b9c0c6e9aa91a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe29f2f08bbbc97be498852cd24dfbc2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_tensor.html#abe29f2f08bbbc97be498852cd24dfbc2">isExecutionTensor</a> () const =0</td></tr>
<tr class="memdesc:abe29f2f08bbbc97be498852cd24dfbc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the tensor is an execution tensor.  <a href="#abe29f2f08bbbc97be498852cd24dfbc2">More...</a><br /></td></tr>
<tr class="separator:abe29f2f08bbbc97be498852cd24dfbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A tensor in a network definition. </p>
<p>to remove a tensor from a network definition, use <a class="el" href="classnvinfer1_1_1_i_network_definition.html#a17e88f382119792187af786c3cc83770" title="remove a tensor from the network definition. ">INetworkDefinition::removeTensor()</a></p>
<dl class="section warning"><dt>Warning</dt><dd>Do not inherit from this class, as doing so will break forward-compatibility of the API and ABI. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a78eb0840f4dcbf05ad40dd82706decf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78eb0840f4dcbf05ad40dd82706decf6">&#9670;&nbsp;</a></span>dynamicRangeIsSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::ITensor::dynamicRangeIsSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether dynamic range is set. </p>
<dl class="section return"><dt>Returns</dt><dd>True if dynamic range is set, false otherwise. </dd></dl>

</div>
</div>
<a id="a83b9b7f16322cf6dbd139f37cbe053a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b9b7f16322cf6dbd139f37cbe053a4">&#9670;&nbsp;</a></span>getAllowedFormats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacenvinfer1.html#ac930bc5598e6612b719019d2e7bf2eb0">TensorFormats</a> nvinfer1::ITensor::getAllowedFormats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a bitmask of TensorFormat values that the tensor supports. For a shape tensor, only row major linear format is allowed. </p>
<dl class="section return"><dt>Returns</dt><dd>The value specified by setAllowedFormats or all possible formats.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#abb6a8ccb84e2e4547371e10574a5bfb4" title="Set allowed formats for this tensor. By default all formats are allowed. Shape tensors (for which isS...">ITensor::setAllowedFormats()</a> </dd></dl>

</div>
</div>
<a id="a48bbf910040e8aeb678da5983edf5021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bbf910040e8aeb678da5983edf5021">&#9670;&nbsp;</a></span>getBroadcastAcrossBatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::ITensor::getBroadcastAcrossBatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if tensor is broadcast across the batch. </p>
<p>When a tensor is broadcast across a batch, it has the same value for every member in the batch. Memory is only allocated once for the single member. If the network is in explicit batch mode, this function returns true if the leading dimension is 1.</p>
<dl class="section return"><dt>Returns</dt><dd>True if tensor is broadcast across the batch, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#ae16776768ec263d07005aaa8b7162895" title="Set whether to enable broadcast of tensor across the batch. ">setBroadcastAcrossBatch()</a> </dd></dl>

</div>
</div>
<a id="a9f05f9eb1b9426b3d70eb646ae18961c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f05f9eb1b9426b3d70eb646ae18961c">&#9670;&nbsp;</a></span>getDimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnvinfer1_1_1_dims.html">Dims</a> nvinfer1::ITensor::getDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimensions of a tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>The dimensions of the tensor.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#a9f05f9eb1b9426b3d70eb646ae18961c" title="Get the dimensions of a tensor. ">getDimensions()</a> returns a -1 for dimensions that are derived from a wildcard dimension. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#a9252b2955e41bd77859c7d610778cbfa" title="Set the dimensions of a tensor. ">setDimensions()</a> </dd></dl>

</div>
</div>
<a id="a5137316c30baaba635321e34b8da366e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5137316c30baaba635321e34b8da366e">&#9670;&nbsp;</a></span>getDynamicRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TRT_DEPRECATED float nvinfer1::ITensor::getDynamicRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get dynamic range for the tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>maximal absolute value of the dynamic range, -1.0f if no dynamic range is set.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>This interface is superceded by getDynamicRangeMin and getDynamicRangeMax. </dd></dl>

</div>
</div>
<a id="ad07cd864b3bc5570cb97a0272eee7685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07cd864b3bc5570cb97a0272eee7685">&#9670;&nbsp;</a></span>getDynamicRangeMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float nvinfer1::ITensor::getDynamicRangeMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum of dynamic range. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum of dynamic range, or quiet NaN if range was not set. </dd></dl>

</div>
</div>
<a id="a07033c8d4b395aeedbc30d370629d179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07033c8d4b395aeedbc30d370629d179">&#9670;&nbsp;</a></span>getDynamicRangeMin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float nvinfer1::ITensor::getDynamicRangeMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get minimum of dynamic range. </p>
<dl class="section return"><dt>Returns</dt><dd>Minimum of dynamic range, or quiet NaN if range was not set. </dd></dl>

</div>
</div>
<a id="a0f2f24dc64a979f54484e42066e648a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2f24dc64a979f54484e42066e648a5">&#9670;&nbsp;</a></span>getLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacenvinfer1.html#aa309b24544789919417899b4d9c504cf">TensorLocation</a> nvinfer1::ITensor::getLocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the storage location of a tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>The location of tensor data. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#a50e38c546bf5d33d82096210791b53d8" title="Set the storage location of a tensor. ">setLocation()</a> </dd></dl>

</div>
</div>
<a id="a13d22afa3925a216cef93191211fdb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d22afa3925a216cef93191211fdb1c">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* nvinfer1::ITensor::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the tensor name. </p>
<dl class="section return"><dt>Returns</dt><dd>The name, as a pointer to a NULL-terminated character sequence.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#a58c30f3df7fc07bac9d9922af30f973a" title="Set the tensor name. ">setName()</a> </dd></dl>

</div>
</div>
<a id="ab873fe0fe824d178b4c53cb725c1e934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab873fe0fe824d178b4c53cb725c1e934">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacenvinfer1.html#afec8200293dc7ed40aca48a763592217">DataType</a> nvinfer1::ITensor::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data type of a tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>The data type of the tensor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#a1004b03f9249097f6d146abc3772819a" title="Set the data type of a tensor. ">setType()</a> </dd></dl>

</div>
</div>
<a id="abe29f2f08bbbc97be498852cd24dfbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe29f2f08bbbc97be498852cd24dfbc2">&#9670;&nbsp;</a></span>isExecutionTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::ITensor::isExecutionTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the tensor is an execution tensor. </p>
<p>If a tensor is an execution tensor and becomes an engine input or output, then <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#abe9ebf7e34e2287e999bd4d77066f9fa" title="True if pointer to tensor data is required for execution phase, false if nullptr can be supplied...">ICudaEngine::isExecutionBinding</a> will be true for that tensor.</p>
<p>Tensors are usually execution tensors. The exceptions are tensors used solely for shape calculations or whose contents not needed to compute the outputs.</p>
<p>A tensor with <a class="el" href="classnvinfer1_1_1_i_tensor.html#a7ebdf9179a63a07d1b9c0c6e9aa91a1d" title="Whether the tensor is a shape tensor. ">isShapeTensor()</a> == false and <a class="el" href="classnvinfer1_1_1_i_tensor.html#abe29f2f08bbbc97be498852cd24dfbc2" title="Whether the tensor is an execution tensor. ">isExecutionTensor()</a> == false can still show up as an input to the engine if its dimensions are required. In that case, only its dimensions need to be set at runtime and a nullptr can be passed instead of a pointer to its contents. </p>

</div>
</div>
<a id="a7ebdf9179a63a07d1b9c0c6e9aa91a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebdf9179a63a07d1b9c0c6e9aa91a1d">&#9670;&nbsp;</a></span>isShapeTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::ITensor::isShapeTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the tensor is a shape tensor. </p>
<p>If a tensor is a shape tensor and becomes an engine input or output, then <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#aac65cc60df4c9d0e62e80448314be369" title="True if tensor is required as input for shape calculations or output from them. ">ICudaEngine::isShapeBinding</a> will be true for that tensor.</p>
<p>It is possible for a tensor to be both a shape tensor and an execution tensor.</p>
<dl class="section return"><dt>Returns</dt><dd>True if tensor is a shape tensor, false otherwise. </dd></dl>

</div>
</div>
<a id="abb6a8ccb84e2e4547371e10574a5bfb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6a8ccb84e2e4547371e10574a5bfb4">&#9670;&nbsp;</a></span>setAllowedFormats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvinfer1::ITensor::setAllowedFormats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvinfer1.html#ac930bc5598e6612b719019d2e7bf2eb0">TensorFormats</a>&#160;</td>
          <td class="paramname"><em>formats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set allowed formats for this tensor. By default all formats are allowed. Shape tensors (for which <a class="el" href="classnvinfer1_1_1_i_tensor.html#a7ebdf9179a63a07d1b9c0c6e9aa91a1d" title="Whether the tensor is a shape tensor. ">isShapeTensor()</a> returns true) may only have row major linear format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formats</td><td>A bitmask of TensorFormat values that are supported for this tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#a83b9b7f16322cf6dbd139f37cbe053a4" title="Get a bitmask of TensorFormat values that the tensor supports. For a shape tensor, only row major linear format is allowed. ">ITensor::getAllowedFormats()</a> </dd></dl>

</div>
</div>
<a id="ae16776768ec263d07005aaa8b7162895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16776768ec263d07005aaa8b7162895">&#9670;&nbsp;</a></span>setBroadcastAcrossBatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvinfer1::ITensor::setBroadcastAcrossBatch </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>broadcastAcrossBatch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether to enable broadcast of tensor across the batch. </p>
<p>When a tensor is broadcast across a batch, it has the same value for every member in the batch. Memory is only allocated once for the single member.</p>
<p>This method is only valid for network input tensors, since the flags of layer output tensors are inferred based on layer inputs and parameters. If this state is modified for a tensor in the network, the states of all dependent tensors will be recomputed. If the tensor is for an explicit batch network, then this function does nothing.</p>
<dl class="section warning"><dt>Warning</dt><dd>The broadcast flag is ignored when using explicit batch network mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">broadcastAcrossBatch</td><td>Whether to enable broadcast of tensor across the batch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#a48bbf910040e8aeb678da5983edf5021" title="Check if tensor is broadcast across the batch. ">getBroadcastAcrossBatch()</a> </dd></dl>

</div>
</div>
<a id="a9252b2955e41bd77859c7d610778cbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9252b2955e41bd77859c7d610778cbfa">&#9670;&nbsp;</a></span>setDimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvinfer1::ITensor::setDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvinfer1_1_1_dims.html">Dims</a>&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the dimensions of a tensor. </p>
<p>For a network input the name is assigned by the application. For a network output it is computed based on the layer parameters and the inputs to the layer. If a tensor size or a parameter is modified in the network, the dimensions of all dependent tensors will be recomputed.</p>
<p>This call is only legal for network input tensors, since the dimensions of layer output tensors are inferred based on layer inputs and parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>The dimensions of the tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#a9f05f9eb1b9426b3d70eb646ae18961c" title="Get the dimensions of a tensor. ">getDimensions()</a> </dd></dl>

</div>
</div>
<a id="a956f662b1d2ebe7ba3aba3391aedddf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956f662b1d2ebe7ba3aba3391aedddf5">&#9670;&nbsp;</a></span>setDynamicRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::ITensor::setDynamicRange </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set dynamic range for the tensor. </p>
<p>Currently, only symmetric ranges are supported. Therefore, the larger of the absolute values of the provided bounds is used.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether the dynamic range was set successfully.</dd></dl>
<p>Requires that min and max be finite, and min &lt;= max. </p>

</div>
</div>
<a id="a50e38c546bf5d33d82096210791b53d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e38c546bf5d33d82096210791b53d8">&#9670;&nbsp;</a></span>setLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvinfer1::ITensor::setLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvinfer1.html#aa309b24544789919417899b4d9c504cf">TensorLocation</a>&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the storage location of a tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>the location of tensor data</td></tr>
  </table>
  </dd>
</dl>
<p>Only network input tensors for storing sequence lengths for RNNv2 are supported. Using host storage for layers that do not support it will generate errors at build time.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#a0f2f24dc64a979f54484e42066e648a5" title="Get the storage location of a tensor. ">getLocation()</a> </dd></dl>

</div>
</div>
<a id="a58c30f3df7fc07bac9d9922af30f973a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c30f3df7fc07bac9d9922af30f973a">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvinfer1::ITensor::setName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the tensor name. </p>
<p>For a network input, the name is assigned by the application. For tensors which are layer outputs, a default name is assigned consisting of the layer name followed by the index of the output in brackets.</p>
<p>This method copies the name string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#a13d22afa3925a216cef93191211fdb1c" title="Get the tensor name. ">getName()</a> </dd></dl>

</div>
</div>
<a id="a1004b03f9249097f6d146abc3772819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1004b03f9249097f6d146abc3772819a">&#9670;&nbsp;</a></span>setType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvinfer1::ITensor::setType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvinfer1.html#afec8200293dc7ed40aca48a763592217">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the data type of a tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The data type of the tensor.</td></tr>
  </table>
  </dd>
</dl>
<p>The type is unchanged if the tensor is not a network input tensor, or marked as an output tensor or shape output tensor.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#ab873fe0fe824d178b4c53cb725c1e934" title="Get the data type of a tensor. ">getType()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_nv_infer_8h_source.html">NvInfer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenvinfer1.html">nvinfer1</a></li><li class="navelem"><a class="el" href="classnvinfer1_1_1_i_tensor.html">ITensor</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
