<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TensorRT: nvinfer1::ICudaEngine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TensorRT
   &#160;<span id="projectnumber">6.0.1.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classnvinfer1_1_1_i_cuda_engine.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnvinfer1_1_1_i_cuda_engine-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nvinfer1::ICudaEngine Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An engine for executing inference on a built network, with functionally unsafe features.  
 <a href="classnvinfer1_1_1_i_cuda_engine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_nv_infer_runtime_8h_source.html">NvInferRuntime.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac78a69ff4fba78c61c90894b74c0826c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#ac78a69ff4fba78c61c90894b74c0826c">getNbBindings</a> () const noexcept=0</td></tr>
<tr class="memdesc:ac78a69ff4fba78c61c90894b74c0826c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of binding indices.  <a href="#ac78a69ff4fba78c61c90894b74c0826c">More...</a><br /></td></tr>
<tr class="separator:ac78a69ff4fba78c61c90894b74c0826c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5af99189eaba37f07509d466b90ba8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8">getBindingIndex</a> (const char *name) const noexcept=0</td></tr>
<tr class="memdesc:a6e5af99189eaba37f07509d466b90ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the binding index for a named tensor.  <a href="#a6e5af99189eaba37f07509d466b90ba8">More...</a><br /></td></tr>
<tr class="separator:a6e5af99189eaba37f07509d466b90ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22d5f8824082e023d13fc067581dfa5"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#ae22d5f8824082e023d13fc067581dfa5">getBindingName</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:ae22d5f8824082e023d13fc067581dfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the name corresponding to a binding index.  <a href="#ae22d5f8824082e023d13fc067581dfa5">More...</a><br /></td></tr>
<tr class="separator:ae22d5f8824082e023d13fc067581dfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9d91496cb301ec730bb568c387ca87"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#aec9d91496cb301ec730bb568c387ca87">bindingIsInput</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:aec9d91496cb301ec730bb568c387ca87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a binding is an input binding.  <a href="#aec9d91496cb301ec730bb568c387ca87">More...</a><br /></td></tr>
<tr class="separator:aec9d91496cb301ec730bb568c387ca87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19759f11fd339cb6f84e37433bb02de"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnvinfer1_1_1_dims.html">Dims</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#ac19759f11fd339cb6f84e37433bb02de">getBindingDimensions</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:ac19759f11fd339cb6f84e37433bb02de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimensions of a binding.  <a href="#ac19759f11fd339cb6f84e37433bb02de">More...</a><br /></td></tr>
<tr class="separator:ac19759f11fd339cb6f84e37433bb02de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b5311b7515c6a9231eea5ad8b8438e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacenvinfer1.html#afec8200293dc7ed40aca48a763592217">DataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a42b5311b7515c6a9231eea5ad8b8438e">getBindingDataType</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:a42b5311b7515c6a9231eea5ad8b8438e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the required data type for a buffer from its binding index.  <a href="#a42b5311b7515c6a9231eea5ad8b8438e">More...</a><br /></td></tr>
<tr class="separator:a42b5311b7515c6a9231eea5ad8b8438e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eeca149f7e2ad8b9ebbf03982396e0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a08eeca149f7e2ad8b9ebbf03982396e0">getMaxBatchSize</a> () const noexcept=0</td></tr>
<tr class="memdesc:a08eeca149f7e2ad8b9ebbf03982396e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum batch size which can be used for inference.  <a href="#a08eeca149f7e2ad8b9ebbf03982396e0">More...</a><br /></td></tr>
<tr class="separator:a08eeca149f7e2ad8b9ebbf03982396e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982a5affea6ec5cb5a859b0d75831a9c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a982a5affea6ec5cb5a859b0d75831a9c">getNbLayers</a> () const noexcept=0</td></tr>
<tr class="memdesc:a982a5affea6ec5cb5a859b0d75831a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of layers in the network.  <a href="#a982a5affea6ec5cb5a859b0d75831a9c">More...</a><br /></td></tr>
<tr class="separator:a982a5affea6ec5cb5a859b0d75831a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f97a9913ac483916932d533c69fb284"><td class="memItemLeft" align="right" valign="top">virtual TRT_DEPRECATED std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a7f97a9913ac483916932d533c69fb284">getWorkspaceSize</a> () const noexcept=0</td></tr>
<tr class="memdesc:a7f97a9913ac483916932d533c69fb284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount of workspace the engine uses.  <a href="#a7f97a9913ac483916932d533c69fb284">More...</a><br /></td></tr>
<tr class="separator:a7f97a9913ac483916932d533c69fb284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230a2f79e79f1d31bf2b64855f3b0ff9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnvinfer1_1_1_i_host_memory.html">IHostMemory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a230a2f79e79f1d31bf2b64855f3b0ff9">serialize</a> () const noexcept=0</td></tr>
<tr class="memdesc:a230a2f79e79f1d31bf2b64855f3b0ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the network to a stream.  <a href="#a230a2f79e79f1d31bf2b64855f3b0ff9">More...</a><br /></td></tr>
<tr class="separator:a230a2f79e79f1d31bf2b64855f3b0ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae394cb9309c6b3f056de3294981b89ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnvinfer1_1_1_i_execution_context.html">IExecutionContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#ae394cb9309c6b3f056de3294981b89ea">createExecutionContext</a> () noexcept=0</td></tr>
<tr class="memdesc:ae394cb9309c6b3f056de3294981b89ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an execution context.  <a href="#ae394cb9309c6b3f056de3294981b89ea">More...</a><br /></td></tr>
<tr class="separator:ae394cb9309c6b3f056de3294981b89ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8683024d2b01889abcb46dee628eb8a6"><td class="memItemLeft" align="right" valign="top"><a id="a8683024d2b01889abcb46dee628eb8a6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a8683024d2b01889abcb46dee628eb8a6">destroy</a> () noexcept=0</td></tr>
<tr class="memdesc:a8683024d2b01889abcb46dee628eb8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy this object;. <br /></td></tr>
<tr class="separator:a8683024d2b01889abcb46dee628eb8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe17bc77ed23990dfaa83cdbb9febcd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacenvinfer1.html#aa309b24544789919417899b4d9c504cf">TensorLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a4fe17bc77ed23990dfaa83cdbb9febcd">getLocation</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:a4fe17bc77ed23990dfaa83cdbb9febcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get location of binding.  <a href="#a4fe17bc77ed23990dfaa83cdbb9febcd">More...</a><br /></td></tr>
<tr class="separator:a4fe17bc77ed23990dfaa83cdbb9febcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773f668a04e6d9aa6b2ac1a02c37f251"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnvinfer1_1_1_i_execution_context.html">IExecutionContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a773f668a04e6d9aa6b2ac1a02c37f251">createExecutionContextWithoutDeviceMemory</a> () noexcept=0</td></tr>
<tr class="memdesc:a773f668a04e6d9aa6b2ac1a02c37f251"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an execution context without any device memory allocated  <a href="#a773f668a04e6d9aa6b2ac1a02c37f251">More...</a><br /></td></tr>
<tr class="separator:a773f668a04e6d9aa6b2ac1a02c37f251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22de1c46f94f59e88d33ef0330be4069"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a22de1c46f94f59e88d33ef0330be4069">getDeviceMemorySize</a> () const noexcept=0</td></tr>
<tr class="memdesc:a22de1c46f94f59e88d33ef0330be4069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the amount of device memory required by an execution context.  <a href="#a22de1c46f94f59e88d33ef0330be4069">More...</a><br /></td></tr>
<tr class="separator:a22de1c46f94f59e88d33ef0330be4069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc63d166dd27cbbf9c3b41ddb6f37d5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#abfc63d166dd27cbbf9c3b41ddb6f37d5">isRefittable</a> () const noexcept=0</td></tr>
<tr class="memdesc:abfc63d166dd27cbbf9c3b41ddb6f37d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if engine can be refit.  <a href="#abfc63d166dd27cbbf9c3b41ddb6f37d5">More...</a><br /></td></tr>
<tr class="separator:abfc63d166dd27cbbf9c3b41ddb6f37d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598d40fc44a1a978607de3224d6dc4ee"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a598d40fc44a1a978607de3224d6dc4ee">getBindingBytesPerComponent</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:a598d40fc44a1a978607de3224d6dc4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes per component of an element.  <a href="#a598d40fc44a1a978607de3224d6dc4ee">More...</a><br /></td></tr>
<tr class="separator:a598d40fc44a1a978607de3224d6dc4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344a20640a4f66d51efae2059abae693"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a344a20640a4f66d51efae2059abae693">getBindingComponentsPerElement</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:a344a20640a4f66d51efae2059abae693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components included in one element.  <a href="#a344a20640a4f66d51efae2059abae693">More...</a><br /></td></tr>
<tr class="separator:a344a20640a4f66d51efae2059abae693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0096a8ccb70b16c249dafe81e731c7c5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacenvinfer1.html#ad26d48b3a534843e9990ab7f903d34a7">TensorFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a0096a8ccb70b16c249dafe81e731c7c5">getBindingFormat</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:a0096a8ccb70b16c249dafe81e731c7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the binding format.  <a href="#a0096a8ccb70b16c249dafe81e731c7c5">More...</a><br /></td></tr>
<tr class="separator:a0096a8ccb70b16c249dafe81e731c7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127e25cd66fd21c69795064447d8c7b5"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a127e25cd66fd21c69795064447d8c7b5">getBindingFormatDesc</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:a127e25cd66fd21c69795064447d8c7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the human readable description of the tensor format.  <a href="#a127e25cd66fd21c69795064447d8c7b5">More...</a><br /></td></tr>
<tr class="separator:a127e25cd66fd21c69795064447d8c7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3293a4acb2bbaeb78b69f802b7a16551"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a3293a4acb2bbaeb78b69f802b7a16551">getBindingVectorizedDim</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:a3293a4acb2bbaeb78b69f802b7a16551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension index that the buffer is vectorized.  <a href="#a3293a4acb2bbaeb78b69f802b7a16551">More...</a><br /></td></tr>
<tr class="separator:a3293a4acb2bbaeb78b69f802b7a16551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3642e4c6164329a36b288a5c3f9a53"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a9f3642e4c6164329a36b288a5c3f9a53">getName</a> () const noexcept=0</td></tr>
<tr class="memdesc:a9f3642e4c6164329a36b288a5c3f9a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the network associated with the engine.  <a href="#a9f3642e4c6164329a36b288a5c3f9a53">More...</a><br /></td></tr>
<tr class="separator:a9f3642e4c6164329a36b288a5c3f9a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd0a5145a5f59bdafa0dac3c76031c3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a4dd0a5145a5f59bdafa0dac3c76031c3">getNbOptimizationProfiles</a> () const noexcept=0</td></tr>
<tr class="memdesc:a4dd0a5145a5f59bdafa0dac3c76031c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of optimization profiles defined for this engine.  <a href="#a4dd0a5145a5f59bdafa0dac3c76031c3">More...</a><br /></td></tr>
<tr class="separator:a4dd0a5145a5f59bdafa0dac3c76031c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eeeab67efad687252c0a356e7caac51"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnvinfer1_1_1_dims.html">Dims</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a8eeeab67efad687252c0a356e7caac51">getProfileDimensions</a> (int bindingIndex, int profileIndex, <a class="el" href="namespacenvinfer1.html#a615f83263a172c061442d1bebfe0735a">OptProfileSelector</a> select) const noexcept=0</td></tr>
<tr class="memdesc:a8eeeab67efad687252c0a356e7caac51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum / optimum / maximum dimensions for a particular binding under an optimization profile.  <a href="#a8eeeab67efad687252c0a356e7caac51">More...</a><br /></td></tr>
<tr class="separator:a8eeeab67efad687252c0a356e7caac51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a055c81f734ddfcc357d3a02082ac9"><td class="memItemLeft" align="right" valign="top">virtual const int32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a60a055c81f734ddfcc357d3a02082ac9">getProfileShapeValues</a> (int profileIndex, int inputIndex, <a class="el" href="namespacenvinfer1.html#a615f83263a172c061442d1bebfe0735a">OptProfileSelector</a> select) const noexcept=0</td></tr>
<tr class="memdesc:a60a055c81f734ddfcc357d3a02082ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum / optimum / maximum values for an input shape binding under an optimization profile.  <a href="#a60a055c81f734ddfcc357d3a02082ac9">More...</a><br /></td></tr>
<tr class="separator:a60a055c81f734ddfcc357d3a02082ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac65cc60df4c9d0e62e80448314be369"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#aac65cc60df4c9d0e62e80448314be369">isShapeBinding</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:aac65cc60df4c9d0e62e80448314be369"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if tensor is required as input for shape calculations or output from them.  <a href="#aac65cc60df4c9d0e62e80448314be369">More...</a><br /></td></tr>
<tr class="separator:aac65cc60df4c9d0e62e80448314be369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9ebf7e34e2287e999bd4d77066f9fa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#abe9ebf7e34e2287e999bd4d77066f9fa">isExecutionBinding</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:abe9ebf7e34e2287e999bd4d77066f9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if pointer to tensor data is required for execution phase, false if nullptr can be supplied.  <a href="#abe9ebf7e34e2287e999bd4d77066f9fa">More...</a><br /></td></tr>
<tr class="separator:abe9ebf7e34e2287e999bd4d77066f9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979cbcf45a952e7373e27baa1e588c71"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacenvinfer1.html#ae1a368a82063d4538abcccbf02f25383">EngineCapability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a979cbcf45a952e7373e27baa1e588c71">getEngineCapability</a> () const noexcept=0</td></tr>
<tr class="memdesc:a979cbcf45a952e7373e27baa1e588c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine that execution capability this engine has.  <a href="#a979cbcf45a952e7373e27baa1e588c71">More...</a><br /></td></tr>
<tr class="separator:a979cbcf45a952e7373e27baa1e588c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a073773ec719db3159d0f91269d7240"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a8a073773ec719db3159d0f91269d7240">setErrorRecorder</a> (<a class="el" href="classnvinfer1_1_1_i_error_recorder.html">IErrorRecorder</a> *recorder) noexcept=0</td></tr>
<tr class="memdesc:a8a073773ec719db3159d0f91269d7240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the ErrorRecorder for this interface.  <a href="#a8a073773ec719db3159d0f91269d7240">More...</a><br /></td></tr>
<tr class="separator:a8a073773ec719db3159d0f91269d7240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8c92b1d37681fb7b1861842bcbef50"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnvinfer1_1_1_i_error_recorder.html">IErrorRecorder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#acb8c92b1d37681fb7b1861842bcbef50">getErrorRecorder</a> () const noexcept=0</td></tr>
<tr class="memdesc:acb8c92b1d37681fb7b1861842bcbef50"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the ErrorRecorder assigned to this interface.  <a href="#acb8c92b1d37681fb7b1861842bcbef50">More...</a><br /></td></tr>
<tr class="separator:acb8c92b1d37681fb7b1861842bcbef50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An engine for executing inference on a built network, with functionally unsafe features. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not inherit from this class, as doing so will break forward-compatibility of the API and ABI. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aec9d91496cb301ec730bb568c387ca87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9d91496cb301ec730bb568c387ca87">&#9670;&nbsp;</a></span>bindingIsInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::ICudaEngine::bindingIsInput </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a binding is an input binding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>The binding index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the index corresponds to an input binding and the index is in range.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">getBindingIndex()</a> </dd></dl>

</div>
</div>
<a id="ae394cb9309c6b3f056de3294981b89ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae394cb9309c6b3f056de3294981b89ea">&#9670;&nbsp;</a></span>createExecutionContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnvinfer1_1_1_i_execution_context.html">IExecutionContext</a>* nvinfer1::ICudaEngine::createExecutionContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an execution context. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_execution_context.html" title="Context for executing inference using an engine, with functionally unsafe features. ">IExecutionContext</a>. </dd></dl>

</div>
</div>
<a id="a773f668a04e6d9aa6b2ac1a02c37f251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773f668a04e6d9aa6b2ac1a02c37f251">&#9670;&nbsp;</a></span>createExecutionContextWithoutDeviceMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnvinfer1_1_1_i_execution_context.html">IExecutionContext</a>* nvinfer1::ICudaEngine::createExecutionContextWithoutDeviceMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an execution context without any device memory allocated </p>
<p>The memory for execution of this device context must be supplied by the application.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a22de1c46f94f59e88d33ef0330be4069" title="Return the amount of device memory required by an execution context. ">getDeviceMemorySize()</a> <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a952c957725cd9ea5044087b523c480d2" title="set the device memory for use by this execution context. ">IExecutionContext::setDeviceMemory()</a> </dd></dl>

</div>
</div>
<a id="a598d40fc44a1a978607de3224d6dc4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598d40fc44a1a978607de3224d6dc4ee">&#9670;&nbsp;</a></span>getBindingBytesPerComponent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nvinfer1::ICudaEngine::getBindingBytesPerComponent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of bytes per component of an element. </p>
<p>The vector component size is returned if <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a3293a4acb2bbaeb78b69f802b7a16551" title="Return the dimension index that the buffer is vectorized. ">getBindingVectorizedDim()</a> != -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>The binding Index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a3293a4acb2bbaeb78b69f802b7a16551" title="Return the dimension index that the buffer is vectorized. ">ICudaEngine::getBindingVectorizedDim()</a> </dd></dl>

</div>
</div>
<a id="a344a20640a4f66d51efae2059abae693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344a20640a4f66d51efae2059abae693">&#9670;&nbsp;</a></span>getBindingComponentsPerElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nvinfer1::ICudaEngine::getBindingComponentsPerElement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of components included in one element. </p>
<p>The number of elements in the vectors is returned if <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a3293a4acb2bbaeb78b69f802b7a16551" title="Return the dimension index that the buffer is vectorized. ">getBindingVectorizedDim()</a> != -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>The binding Index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a3293a4acb2bbaeb78b69f802b7a16551" title="Return the dimension index that the buffer is vectorized. ">ICudaEngine::getBindingVectorizedDim()</a> </dd></dl>

</div>
</div>
<a id="a42b5311b7515c6a9231eea5ad8b8438e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b5311b7515c6a9231eea5ad8b8438e">&#9670;&nbsp;</a></span>getBindingDataType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacenvinfer1.html#afec8200293dc7ed40aca48a763592217">DataType</a> nvinfer1::ICudaEngine::getBindingDataType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the required data type for a buffer from its binding index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>The binding index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the data in the buffer.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">getBindingIndex()</a> </dd></dl>

</div>
</div>
<a id="ac19759f11fd339cb6f84e37433bb02de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19759f11fd339cb6f84e37433bb02de">&#9670;&nbsp;</a></span>getBindingDimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnvinfer1_1_1_dims.html">Dims</a> nvinfer1::ICudaEngine::getBindingDimensions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimensions of a binding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>The binding index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dimensions of the binding if the index is in range, otherwise Dims() Has -1 for any dimension with a dynamic value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">getBindingIndex()</a> </dd></dl>

</div>
</div>
<a id="a0096a8ccb70b16c249dafe81e731c7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0096a8ccb70b16c249dafe81e731c7c5">&#9670;&nbsp;</a></span>getBindingFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacenvinfer1.html#ad26d48b3a534843e9990ab7f903d34a7">TensorFormat</a> nvinfer1::ICudaEngine::getBindingFormat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the binding format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>The binding Index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a127e25cd66fd21c69795064447d8c7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127e25cd66fd21c69795064447d8c7b5">&#9670;&nbsp;</a></span>getBindingFormatDesc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* nvinfer1::ICudaEngine::getBindingFormatDesc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the human readable description of the tensor format. </p>
<p>The description includes the order, vectorization, data type, strides, and etc. Examples are shown as follows: Example 1: kCHW + FP32 "Row major linear FP32 format" Example 2: kCHW2 + FP16 "Two wide channel vectorized row major FP16 format" Example 3: kHWC8 + FP16 + Line Stride = 32 "Channel major FP16 format where C % 8 == 0 and H Stride % 32 == 0"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>The binding Index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e5af99189eaba37f07509d466b90ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5af99189eaba37f07509d466b90ba8">&#9670;&nbsp;</a></span>getBindingIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nvinfer1::ICudaEngine::getBindingIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the binding index for a named tensor. </p>
<p><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a84436f784eb3f0ea9089de2678d77954" title="Asynchronously execute inference on a batch. ">IExecutionContext::enqueue()</a> and <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a1fba6d417077b30a270d623119d02731" title="Synchronously execute inference on a batch. ">IExecutionContext::execute()</a> require an array of buffers.</p>
<p>Engine bindings map from tensor names to indices in this array. Binding indices are assigned at engine build time, and take values in the range [0 ... n-1] where n is the total number of inputs and outputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The tensor name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binding index for the named tensor, or -1 if the name is not found.</dd></dl>
<p>see <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#ac78a69ff4fba78c61c90894b74c0826c" title="Get the number of binding indices. ">getNbBindings()</a> <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">getBindingIndex()</a> </p>

</div>
</div>
<a id="ae22d5f8824082e023d13fc067581dfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22d5f8824082e023d13fc067581dfa5">&#9670;&nbsp;</a></span>getBindingName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* nvinfer1::ICudaEngine::getBindingName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the name corresponding to a binding index. </p>
<p>This is the reverse mapping to that provided by <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">getBindingIndex()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>The binding index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name corresponding to the index, or nullptr if the index is out of range.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">getBindingIndex()</a> </dd></dl>

</div>
</div>
<a id="a3293a4acb2bbaeb78b69f802b7a16551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3293a4acb2bbaeb78b69f802b7a16551">&#9670;&nbsp;</a></span>getBindingVectorizedDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nvinfer1::ICudaEngine::getBindingVectorizedDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the dimension index that the buffer is vectorized. </p>
<p>Specifically -1 is returned if scalars per vector is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>The binding Index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22de1c46f94f59e88d33ef0330be4069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22de1c46f94f59e88d33ef0330be4069">&#9670;&nbsp;</a></span>getDeviceMemorySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t nvinfer1::ICudaEngine::getDeviceMemorySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the amount of device memory required by an execution context. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a952c957725cd9ea5044087b523c480d2" title="set the device memory for use by this execution context. ">IExecutionContext::setDeviceMemory()</a> </dd></dl>

</div>
</div>
<a id="a979cbcf45a952e7373e27baa1e588c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979cbcf45a952e7373e27baa1e588c71">&#9670;&nbsp;</a></span>getEngineCapability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacenvinfer1.html#ae1a368a82063d4538abcccbf02f25383">EngineCapability</a> nvinfer1::ICudaEngine::getEngineCapability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>determine that execution capability this engine has. </p>
<p>If the engine has <a class="el" href="namespacenvinfer1.html#ae1a368a82063d4538abcccbf02f25383a2eb05989f1bbfd98f356f4f3ac2ba2ec" title="Full capability, TensorRT mode without any restrictions. ">EngineCapability::kDEFAULT</a>, then all engine functionality is valid.. If the engine has <a class="el" href="namespacenvinfer1.html#ae1a368a82063d4538abcccbf02f25383ad2298f1c40120466f5d4dc4e664095d0" title="Safety restricted capability, TensorRT flow that can only run on GPU devices. ">EngineCapability::kSAFE_GPU</a>, then only the functionality in safe::ICudaEngine is valid. If the engine has <a class="el" href="namespacenvinfer1.html#ae1a368a82063d4538abcccbf02f25383a5b44fe262f772396a08fbf720d156a64" title="Safety restricted capability, TensorRT flow that can only run on DLA devices. ">EngineCapability::kSAFE_DLA</a>, then only serialize, destroy, and const-accessor functions are valid.</p>
<dl class="section return"><dt>Returns</dt><dd>The EngineCapability flag that the engine was built for. </dd></dl>

</div>
</div>
<a id="acb8c92b1d37681fb7b1861842bcbef50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8c92b1d37681fb7b1861842bcbef50">&#9670;&nbsp;</a></span>getErrorRecorder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnvinfer1_1_1_i_error_recorder.html">IErrorRecorder</a>* nvinfer1::ICudaEngine::getErrorRecorder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the ErrorRecorder assigned to this interface. </p>
<p>Retrieves the assigned error recorder object for the given class. A default error recorder does not exist, so a nullptr will be returned if setErrorRecorder has not been called.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="classnvinfer1_1_1_i_error_recorder.html" title="Reference counted application-implemented error reporting interface for TensorRT objects. ">IErrorRecorder</a> object that has been registered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a8a073773ec719db3159d0f91269d7240" title="Set the ErrorRecorder for this interface. ">setErrorRecorder</a> </dd></dl>

</div>
</div>
<a id="a4fe17bc77ed23990dfaa83cdbb9febcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe17bc77ed23990dfaa83cdbb9febcd">&#9670;&nbsp;</a></span>getLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacenvinfer1.html#aa309b24544789919417899b4d9c504cf">TensorLocation</a> nvinfer1::ICudaEngine::getLocation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get location of binding. </p>
<p>This lets you know whether the binding should be a pointer to device or host memory.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_tensor.html#a50e38c546bf5d33d82096210791b53d8" title="Set the storage location of a tensor. ">ITensor::setLocation()</a> <a class="el" href="classnvinfer1_1_1_i_tensor.html#a0f2f24dc64a979f54484e42066e648a5" title="Get the storage location of a tensor. ">ITensor::getLocation()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>The binding index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The location of the bound tensor with given index. </dd></dl>

</div>
</div>
<a id="a08eeca149f7e2ad8b9ebbf03982396e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eeca149f7e2ad8b9ebbf03982396e0">&#9670;&nbsp;</a></span>getMaxBatchSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nvinfer1::ICudaEngine::getMaxBatchSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum batch size which can be used for inference. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum batch size for this engine. </dd></dl>

</div>
</div>
<a id="a9f3642e4c6164329a36b288a5c3f9a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3642e4c6164329a36b288a5c3f9a53">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* nvinfer1::ICudaEngine::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the network associated with the engine. </p>
<p>The name is set during network creation and is retrieved after building or deserialization.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_network_definition.html#a2d3ffd5af77299ca45ab7a286e21eaef" title="Sets the name of the network. ">INetworkDefinition::setName()</a>, <a class="el" href="classnvinfer1_1_1_i_network_definition.html#ae6b53187d680c53e89c19cd39bc66beb" title="Returns the name associated with the network. ">INetworkDefinition::getName()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A zero delimited C-style string representing the name of the network. </dd></dl>

</div>
</div>
<a id="ac78a69ff4fba78c61c90894b74c0826c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78a69ff4fba78c61c90894b74c0826c">&#9670;&nbsp;</a></span>getNbBindings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nvinfer1::ICudaEngine::getNbBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of binding indices. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">getBindingIndex()</a>; </dd></dl>

</div>
</div>
<a id="a982a5affea6ec5cb5a859b0d75831a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982a5affea6ec5cb5a859b0d75831a9c">&#9670;&nbsp;</a></span>getNbLayers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nvinfer1::ICudaEngine::getNbLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of layers in the network. </p>
<p>The number of layers in the network is not necessarily the number in the original network definition, as layers may be combined or eliminated as the engine is optimized. This value can be useful when building per-layer tables, such as when aggregating profiling data over a number of executions.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of layers in the network. </dd></dl>

</div>
</div>
<a id="a4dd0a5145a5f59bdafa0dac3c76031c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd0a5145a5f59bdafa0dac3c76031c3">&#9670;&nbsp;</a></span>getNbOptimizationProfiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nvinfer1::ICudaEngine::getNbOptimizationProfiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of optimization profiles defined for this engine. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of optimization profiles. It is always at least 1.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_execution_context.html#aba0731b9fbc926c477010df818650b0a" title="Select an optimization profile for the current context. ">IExecutionContext::setOptimizationProfile()</a> </dd></dl>

</div>
</div>
<a id="a8eeeab67efad687252c0a356e7caac51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eeeab67efad687252c0a356e7caac51">&#9670;&nbsp;</a></span>getProfileDimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnvinfer1_1_1_dims.html">Dims</a> nvinfer1::ICudaEngine::getProfileDimensions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profileIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvinfer1.html#a615f83263a172c061442d1bebfe0735a">OptProfileSelector</a>&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum / optimum / maximum dimensions for a particular binding under an optimization profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>The binding index (must be between 0 and <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#ac78a69ff4fba78c61c90894b74c0826c" title="Get the number of binding indices. ">getNbBindings()</a> - 1)</td></tr>
    <tr><td class="paramname">profileIndex</td><td>The profile index (must be between 0 and <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a4dd0a5145a5f59bdafa0dac3c76031c3" title="Get the number of optimization profiles defined for this engine. ">getNbOptimizationProfiles()</a>-1)</td></tr>
    <tr><td class="paramname">select</td><td>Whether to query the minimum, optimum, or maximum dimensions for this binding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum / optimum / maximum dimensions for this binding in this profile. </dd></dl>

</div>
</div>
<a id="a60a055c81f734ddfcc357d3a02082ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a055c81f734ddfcc357d3a02082ac9">&#9670;&nbsp;</a></span>getProfileShapeValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const int32_t* nvinfer1::ICudaEngine::getProfileShapeValues </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profileIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvinfer1.html#a615f83263a172c061442d1bebfe0735a">OptProfileSelector</a>&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get minimum / optimum / maximum values for an input shape binding under an optimization profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileIndex</td><td>The profile index (must be between 0 and <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a4dd0a5145a5f59bdafa0dac3c76031c3" title="Get the number of optimization profiles defined for this engine. ">getNbOptimizationProfiles()</a>-1)</td></tr>
    <tr><td class="paramname">inputIndex</td><td>The input index (must be between 0 and <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#ac78a69ff4fba78c61c90894b74c0826c" title="Get the number of binding indices. ">getNbBindings()</a> - 1)</td></tr>
    <tr><td class="paramname">select</td><td>Whether to query the minimum, optimum, or maximum shape values for this binding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the binding is an input shape binding, return a pointer to an array that has the same number of elements as the corresponding tensor, i.e. 1 if dims.nbDims == 0, or dims.d[0] if dims.nbDims == 1, where dims = getBindingDimensions(inputIndex). The array contains the elementwise minimum / optimum / maximum values for this shape binding under the profile. If either of the indices is out of range, or if the binding is not an input shape binding, return nullptr. </dd></dl>

</div>
</div>
<a id="a7f97a9913ac483916932d533c69fb284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f97a9913ac483916932d533c69fb284">&#9670;&nbsp;</a></span>getWorkspaceSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TRT_DEPRECATED std::size_t nvinfer1::ICudaEngine::getWorkspaceSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the amount of workspace the engine uses. </p>
<p>The workspace size will be no greater than the value provided to the builder when the engine was built, and will typically be smaller. Workspace will be allocated for each execution context. </p>

</div>
</div>
<a id="abe9ebf7e34e2287e999bd4d77066f9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9ebf7e34e2287e999bd4d77066f9fa">&#9670;&nbsp;</a></span>isExecutionBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::ICudaEngine::isExecutionBinding </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if pointer to tensor data is required for execution phase, false if nullptr can be supplied. </p>
<p>For example, if a network uses an input tensor with binding i ONLY as the "reshape dimensions" input of <a class="el" href="classnvinfer1_1_1_i_shuffle_layer.html" title="Layer type for shuffling data. ">IShuffleLayer</a>, then isExecutionBinding(i) is false, and a nullptr can be supplied for it when calling <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a1fba6d417077b30a270d623119d02731" title="Synchronously execute inference on a batch. ">IExecutionContext::execute</a> or <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a84436f784eb3f0ea9089de2678d77954" title="Asynchronously execute inference on a batch. ">IExecutionContext::enqueue</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#aac65cc60df4c9d0e62e80448314be369" title="True if tensor is required as input for shape calculations or output from them. ">isShapeBinding()</a> </dd></dl>

</div>
</div>
<a id="abfc63d166dd27cbbf9c3b41ddb6f37d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc63d166dd27cbbf9c3b41ddb6f37d5">&#9670;&nbsp;</a></span>isRefittable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::ICudaEngine::isRefittable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if engine can be refit. </p>
<dl class="section see"><dt>See also</dt><dd>nvinfer1::createInferRefitter() </dd></dl>

</div>
</div>
<a id="aac65cc60df4c9d0e62e80448314be369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac65cc60df4c9d0e62e80448314be369">&#9670;&nbsp;</a></span>isShapeBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::ICudaEngine::isShapeBinding </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if tensor is required as input for shape calculations or output from them. </p>
<p>TensorRT evaluates a network in two phases:</p>
<ol type="1">
<li>Compute shape information required to determine memory allocation requirements and validate that runtime sizes make sense.</li>
<li>Process tensors on the device.</li>
</ol>
<p>Some tensors are required in phase 1. These tensors are called "shape tensors", and always have type Int32 and no more than one dimension. These tensors are not always shapes themselves, but might be used to calculate tensor shapes for phase 2.</p>
<p>isShapeBinding(i) returns true if the tensor is a required input or an output computed in phase 1. isExecutionBinding(i) returns true if the tensor is a required input or an output computed in phase 2.</p>
<p>For example, if a network uses an input tensor with binding i as an addend to an <a class="el" href="classnvinfer1_1_1_i_element_wise_layer.html" title="A elementwise layer in a network definition. ">IElementWiseLayer</a> that computes the "reshape dimensions" for <a class="el" href="classnvinfer1_1_1_i_shuffle_layer.html" title="Layer type for shuffling data. ">IShuffleLayer</a>, then isShapeBinding(i) == true.</p>
<p>It's possible to have a tensor be required by both phases. For instance, a tensor can be used for the "reshape dimensions" and as the indices for an <a class="el" href="classnvinfer1_1_1_i_gather_layer.html">IGatherLayer</a> collecting floating-point data.</p>
<p>It's also possible to have a tensor be required by neither phase, but nonetheless shows up in the engine's inputs. For example, if an input tensor is used only as an input to <a class="el" href="classnvinfer1_1_1_i_shape_layer.html" title="Layer type for getting shape of a tensor. ">IShapeLayer</a>, only its shape matters and its values are irrelevant.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#abe9ebf7e34e2287e999bd4d77066f9fa" title="True if pointer to tensor data is required for execution phase, false if nullptr can be supplied...">isExecutionBinding()</a> </dd></dl>

</div>
</div>
<a id="a230a2f79e79f1d31bf2b64855f3b0ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230a2f79e79f1d31bf2b64855f3b0ff9">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnvinfer1_1_1_i_host_memory.html">IHostMemory</a>* nvinfer1::ICudaEngine::serialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize the network to a stream. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classnvinfer1_1_1_i_host_memory.html" title="Class to handle library allocated memory that is accessible to the user. ">IHostMemory</a> object that contains the serialized engine.</dd></dl>
<p>The network may be deserialized with <a class="el" href="classnvinfer1_1_1_i_runtime.html#abbcb22a6b2a2a77174e43e6f6bcc2fd1" title="Deserialize an engine from a stream. ">IRuntime::deserializeCudaEngine()</a> and also safe::IRuntime::deserializeCudaEngine() if only functional-safe features are used in the engine.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_runtime.html#abbcb22a6b2a2a77174e43e6f6bcc2fd1" title="Deserialize an engine from a stream. ">IRuntime::deserializeCudaEngine()</a> safe::IRuntime::deserializeCudaEngine() </dd></dl>

</div>
</div>
<a id="a8a073773ec719db3159d0f91269d7240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a073773ec719db3159d0f91269d7240">&#9670;&nbsp;</a></span>setErrorRecorder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvinfer1::ICudaEngine::setErrorRecorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvinfer1_1_1_i_error_recorder.html">IErrorRecorder</a> *&#160;</td>
          <td class="paramname"><em>recorder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the ErrorRecorder for this interface. </p>
<p>Assigns the ErrorRecorder to this interface. The ErrorRecorder will track all errors during execution. This function will call incRefCount of the registered ErrorRecorder at least once. Setting recorder to nullptr unregisters the recorder with the interface, resulting in a call to decRefCount if a recorder has been registered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recorder</td><td>The error recorder to register with this interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#acb8c92b1d37681fb7b1861842bcbef50" title="get the ErrorRecorder assigned to this interface. ">getErrorRecorder</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_nv_infer_runtime_8h_source.html">NvInferRuntime.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenvinfer1.html">nvinfer1</a></li><li class="navelem"><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html">ICudaEngine</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
