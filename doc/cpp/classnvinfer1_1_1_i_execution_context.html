<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TensorRT: nvinfer1::IExecutionContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TensorRT
   &#160;<span id="projectnumber">6.0.1.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classnvinfer1_1_1_i_execution_context.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnvinfer1_1_1_i_execution_context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nvinfer1::IExecutionContext Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Context for executing inference using an engine, with functionally unsafe features.  
 <a href="classnvinfer1_1_1_i_execution_context.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_nv_infer_runtime_8h_source.html">NvInferRuntime.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1fba6d417077b30a270d623119d02731"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a1fba6d417077b30a270d623119d02731">execute</a> (int batchSize, void **bindings) noexcept=0</td></tr>
<tr class="memdesc:a1fba6d417077b30a270d623119d02731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute inference on a batch.  <a href="#a1fba6d417077b30a270d623119d02731">More...</a><br /></td></tr>
<tr class="separator:a1fba6d417077b30a270d623119d02731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84436f784eb3f0ea9089de2678d77954"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a84436f784eb3f0ea9089de2678d77954">enqueue</a> (int batchSize, void **bindings, <a class="el" href="_nv_infer_runtime_common_8h.html#ae15d9c8b7a240312b533d6122558085a">cudaStream_t</a> stream, <a class="el" href="_nv_infer_runtime_common_8h.html#aea2f543a9fc0e52fe4ae712920fd1247">cudaEvent_t</a> *inputConsumed) noexcept=0</td></tr>
<tr class="memdesc:a84436f784eb3f0ea9089de2678d77954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously execute inference on a batch.  <a href="#a84436f784eb3f0ea9089de2678d77954">More...</a><br /></td></tr>
<tr class="separator:a84436f784eb3f0ea9089de2678d77954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0d31911cd4873ac364d1193cc42de7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a5c0d31911cd4873ac364d1193cc42de7">setDebugSync</a> (bool sync) noexcept=0</td></tr>
<tr class="memdesc:a5c0d31911cd4873ac364d1193cc42de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the debug sync flag.  <a href="#a5c0d31911cd4873ac364d1193cc42de7">More...</a><br /></td></tr>
<tr class="separator:a5c0d31911cd4873ac364d1193cc42de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79088a93559183b46765981c96ca9f01"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a79088a93559183b46765981c96ca9f01">getDebugSync</a> () const noexcept=0</td></tr>
<tr class="memdesc:a79088a93559183b46765981c96ca9f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the debug sync flag.  <a href="#a79088a93559183b46765981c96ca9f01">More...</a><br /></td></tr>
<tr class="separator:a79088a93559183b46765981c96ca9f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e72ed71fa265277b3bac4c1de765f1a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a0e72ed71fa265277b3bac4c1de765f1a">setProfiler</a> (<a class="el" href="classnvinfer1_1_1_i_profiler.html">IProfiler</a> *) noexcept=0</td></tr>
<tr class="memdesc:a0e72ed71fa265277b3bac4c1de765f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the profiler.  <a href="#a0e72ed71fa265277b3bac4c1de765f1a">More...</a><br /></td></tr>
<tr class="separator:a0e72ed71fa265277b3bac4c1de765f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2600d03ec4703fb15071069ae4ff38f6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnvinfer1_1_1_i_profiler.html">IProfiler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a2600d03ec4703fb15071069ae4ff38f6">getProfiler</a> () const noexcept=0</td></tr>
<tr class="memdesc:a2600d03ec4703fb15071069ae4ff38f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the profiler.  <a href="#a2600d03ec4703fb15071069ae4ff38f6">More...</a><br /></td></tr>
<tr class="separator:a2600d03ec4703fb15071069ae4ff38f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a1424c402db671befbcdb5eccb77d2"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html">ICudaEngine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#aa7a1424c402db671befbcdb5eccb77d2">getEngine</a> () const noexcept=0</td></tr>
<tr class="memdesc:aa7a1424c402db671befbcdb5eccb77d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the associated engine.  <a href="#aa7a1424c402db671befbcdb5eccb77d2">More...</a><br /></td></tr>
<tr class="separator:aa7a1424c402db671befbcdb5eccb77d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9e564d413e4087a1c8c6335471950e"><td class="memItemLeft" align="right" valign="top"><a id="afe9e564d413e4087a1c8c6335471950e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#afe9e564d413e4087a1c8c6335471950e">destroy</a> () noexcept=0</td></tr>
<tr class="memdesc:afe9e564d413e4087a1c8c6335471950e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy this object. <br /></td></tr>
<tr class="separator:afe9e564d413e4087a1c8c6335471950e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43a687b8bf5e12cbb1fc340bf63b245"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#ac43a687b8bf5e12cbb1fc340bf63b245">setName</a> (const char *name) noexcept=0</td></tr>
<tr class="memdesc:ac43a687b8bf5e12cbb1fc340bf63b245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the execution context.  <a href="#ac43a687b8bf5e12cbb1fc340bf63b245">More...</a><br /></td></tr>
<tr class="separator:ac43a687b8bf5e12cbb1fc340bf63b245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb63dace49fab3c5dfae0f61167c0a33"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#adb63dace49fab3c5dfae0f61167c0a33">getName</a> () const noexcept=0</td></tr>
<tr class="memdesc:adb63dace49fab3c5dfae0f61167c0a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the execution context.  <a href="#adb63dace49fab3c5dfae0f61167c0a33">More...</a><br /></td></tr>
<tr class="separator:adb63dace49fab3c5dfae0f61167c0a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952c957725cd9ea5044087b523c480d2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a952c957725cd9ea5044087b523c480d2">setDeviceMemory</a> (void *memory) noexcept=0</td></tr>
<tr class="memdesc:a952c957725cd9ea5044087b523c480d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the device memory for use by this execution context.  <a href="#a952c957725cd9ea5044087b523c480d2">More...</a><br /></td></tr>
<tr class="separator:a952c957725cd9ea5044087b523c480d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ebf5bd5b925446296b1652cf63f4d8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnvinfer1_1_1_dims.html">Dims</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a84ebf5bd5b925446296b1652cf63f4d8">getStrides</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:a84ebf5bd5b925446296b1652cf63f4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the strides of the buffer for the given binding.  <a href="#a84ebf5bd5b925446296b1652cf63f4d8">More...</a><br /></td></tr>
<tr class="separator:a84ebf5bd5b925446296b1652cf63f4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0731b9fbc926c477010df818650b0a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#aba0731b9fbc926c477010df818650b0a">setOptimizationProfile</a> (int profileIndex) noexcept=0</td></tr>
<tr class="memdesc:aba0731b9fbc926c477010df818650b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an optimization profile for the current context.  <a href="#aba0731b9fbc926c477010df818650b0a">More...</a><br /></td></tr>
<tr class="separator:aba0731b9fbc926c477010df818650b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6a76a642ee2f9619cf090947b7043e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#abb6a76a642ee2f9619cf090947b7043e">getOptimizationProfile</a> () const noexcept=0</td></tr>
<tr class="memdesc:abb6a76a642ee2f9619cf090947b7043e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the currently selected optimization profile.  <a href="#abb6a76a642ee2f9619cf090947b7043e">More...</a><br /></td></tr>
<tr class="separator:abb6a76a642ee2f9619cf090947b7043e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f87003474bc387e17782292cc2ea613"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a9f87003474bc387e17782292cc2ea613">setBindingDimensions</a> (int bindingIndex, <a class="el" href="classnvinfer1_1_1_dims.html">Dims</a> dimensions) noexcept=0</td></tr>
<tr class="memdesc:a9f87003474bc387e17782292cc2ea613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the dynamic dimensions of a binding.  <a href="#a9f87003474bc387e17782292cc2ea613">More...</a><br /></td></tr>
<tr class="separator:a9f87003474bc387e17782292cc2ea613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af915b83bfe8f5f8c02115f4a85e418ca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnvinfer1_1_1_dims.html">Dims</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#af915b83bfe8f5f8c02115f4a85e418ca">getBindingDimensions</a> (int bindingIndex) const noexcept=0</td></tr>
<tr class="memdesc:af915b83bfe8f5f8c02115f4a85e418ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dynamic dimensions of a binding.  <a href="#af915b83bfe8f5f8c02115f4a85e418ca">More...</a><br /></td></tr>
<tr class="separator:af915b83bfe8f5f8c02115f4a85e418ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306a7c94521d6a211be715ceb07c8c80"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a306a7c94521d6a211be715ceb07c8c80">setInputShapeBinding</a> (int bindingIndex, const int32_t *data) noexcept=0</td></tr>
<tr class="memdesc:a306a7c94521d6a211be715ceb07c8c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set values of input tensor required by shape calculations.  <a href="#a306a7c94521d6a211be715ceb07c8c80">More...</a><br /></td></tr>
<tr class="separator:a306a7c94521d6a211be715ceb07c8c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afb239c59299f5e88a617781d294d44"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a3afb239c59299f5e88a617781d294d44">getShapeBinding</a> (int bindingIndex, int32_t *data) const noexcept=0</td></tr>
<tr class="memdesc:a3afb239c59299f5e88a617781d294d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get values of an input tensor required for shape calculations or an output tensor produced by shape calculations.  <a href="#a3afb239c59299f5e88a617781d294d44">More...</a><br /></td></tr>
<tr class="separator:a3afb239c59299f5e88a617781d294d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a7d80b6536a2ae68ae5ad7f2843c67"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a76a7d80b6536a2ae68ae5ad7f2843c67">allInputDimensionsSpecified</a> () const noexcept=0</td></tr>
<tr class="memdesc:a76a7d80b6536a2ae68ae5ad7f2843c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all dynamic dimensions of input tensors have been specified.  <a href="#a76a7d80b6536a2ae68ae5ad7f2843c67">More...</a><br /></td></tr>
<tr class="separator:a76a7d80b6536a2ae68ae5ad7f2843c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80144d10e666ff6ba33222d4f7212fa1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a80144d10e666ff6ba33222d4f7212fa1">allInputShapesSpecified</a> () const noexcept=0</td></tr>
<tr class="memdesc:a80144d10e666ff6ba33222d4f7212fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all input shape bindings have been specified.  <a href="#a80144d10e666ff6ba33222d4f7212fa1">More...</a><br /></td></tr>
<tr class="separator:a80144d10e666ff6ba33222d4f7212fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728ba0406b1d20d3bec9bfd8bbcefd2e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a728ba0406b1d20d3bec9bfd8bbcefd2e">setErrorRecorder</a> (<a class="el" href="classnvinfer1_1_1_i_error_recorder.html">IErrorRecorder</a> *recorder) noexcept=0</td></tr>
<tr class="memdesc:a728ba0406b1d20d3bec9bfd8bbcefd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the ErrorRecorder for this interface.  <a href="#a728ba0406b1d20d3bec9bfd8bbcefd2e">More...</a><br /></td></tr>
<tr class="separator:a728ba0406b1d20d3bec9bfd8bbcefd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020e0a5be09f9d87f7abc4d03d94e0e6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnvinfer1_1_1_i_error_recorder.html">IErrorRecorder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a020e0a5be09f9d87f7abc4d03d94e0e6">getErrorRecorder</a> () const noexcept=0</td></tr>
<tr class="memdesc:a020e0a5be09f9d87f7abc4d03d94e0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the ErrorRecorder assigned to this interface.  <a href="#a020e0a5be09f9d87f7abc4d03d94e0e6">More...</a><br /></td></tr>
<tr class="separator:a020e0a5be09f9d87f7abc4d03d94e0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4baca5d4e8642905d487aaf7ca01c5ea"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a4baca5d4e8642905d487aaf7ca01c5ea">executeV2</a> (void **bindings) noexcept=0</td></tr>
<tr class="memdesc:a4baca5d4e8642905d487aaf7ca01c5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute inference a network.  <a href="#a4baca5d4e8642905d487aaf7ca01c5ea">More...</a><br /></td></tr>
<tr class="separator:a4baca5d4e8642905d487aaf7ca01c5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a5737264c2b7860baef0096d961f5a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvinfer1_1_1_i_execution_context.html#ac7a5737264c2b7860baef0096d961f5a">enqueueV2</a> (void **bindings, <a class="el" href="_nv_infer_runtime_common_8h.html#ae15d9c8b7a240312b533d6122558085a">cudaStream_t</a> stream, <a class="el" href="_nv_infer_runtime_common_8h.html#aea2f543a9fc0e52fe4ae712920fd1247">cudaEvent_t</a> *inputConsumed) noexcept=0</td></tr>
<tr class="memdesc:ac7a5737264c2b7860baef0096d961f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously execute inference.  <a href="#ac7a5737264c2b7860baef0096d961f5a">More...</a><br /></td></tr>
<tr class="separator:ac7a5737264c2b7860baef0096d961f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Context for executing inference using an engine, with functionally unsafe features. </p>
<p>Multiple execution contexts may exist for one <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html" title="An engine for executing inference on a built network, with functionally unsafe features. ">ICudaEngine</a> instance, allowing the same engine to be used for the execution of multiple batches simultaneously. If the engine supports dynamic shapes, each execution context in concurrent use must use a separate optimization profile.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not inherit from this class, as doing so will break forward-compatibility of the API and ABI. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a76a7d80b6536a2ae68ae5ad7f2843c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a7d80b6536a2ae68ae5ad7f2843c67">&#9670;&nbsp;</a></span>allInputDimensionsSpecified()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::IExecutionContext::allInputDimensionsSpecified </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether all dynamic dimensions of input tensors have been specified. </p>
<dl class="section return"><dt>Returns</dt><dd>True if all dynamic dimensions of input tensors have been specified by calling <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a9f87003474bc387e17782292cc2ea613" title="Set the dynamic dimensions of a binding. ">setBindingDimensions()</a>.</dd></dl>
<p>Trivially true if network has no dynamically shaped input tensors.</p>
<dl class="section see"><dt>See also</dt><dd>setBindingDimensions(bindingIndex,dimensions) </dd></dl>

</div>
</div>
<a id="a80144d10e666ff6ba33222d4f7212fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80144d10e666ff6ba33222d4f7212fa1">&#9670;&nbsp;</a></span>allInputShapesSpecified()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::IExecutionContext::allInputShapesSpecified </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether all input shape bindings have been specified. </p>
<dl class="section return"><dt>Returns</dt><dd>True if all input shape bindings have been specified by <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a306a7c94521d6a211be715ceb07c8c80" title="Set values of input tensor required by shape calculations. ">setInputShapeBinding()</a>.</dd></dl>
<p>Trivially true if network has no input shape bindings.</p>
<dl class="section see"><dt>See also</dt><dd>isShapeBinding(bindingIndex) </dd></dl>

</div>
</div>
<a id="a84436f784eb3f0ea9089de2678d77954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84436f784eb3f0ea9089de2678d77954">&#9670;&nbsp;</a></span>enqueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::IExecutionContext::enqueue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>batchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_infer_runtime_common_8h.html#ae15d9c8b7a240312b533d6122558085a">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_infer_runtime_common_8h.html#aea2f543a9fc0e52fe4ae712920fd1247">cudaEvent_t</a> *&#160;</td>
          <td class="paramname"><em>inputConsumed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously execute inference on a batch. </p>
<p>This method requires an array of input and output buffers. The mapping from tensor names to indices can be queried using <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">ICudaEngine::getBindingIndex()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batchSize</td><td>The batch size. This is at most the value supplied when the engine was built. </td></tr>
    <tr><td class="paramname">bindings</td><td>An array of pointers to input and output buffers for the network. </td></tr>
    <tr><td class="paramname">stream</td><td>A cuda stream on which the inference kernels will be enqueued </td></tr>
    <tr><td class="paramname">inputConsumed</td><td>An optional event which will be signaled when the input buffers can be refilled with new data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the kernels were enqueued successfully.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">ICudaEngine::getBindingIndex()</a> <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a08eeca149f7e2ad8b9ebbf03982396e0" title="Get the maximum batch size which can be used for inference. ">ICudaEngine::getMaxBatchSize()</a> </dd></dl>

</div>
</div>
<a id="ac7a5737264c2b7860baef0096d961f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a5737264c2b7860baef0096d961f5a">&#9670;&nbsp;</a></span>enqueueV2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::IExecutionContext::enqueueV2 </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_infer_runtime_common_8h.html#ae15d9c8b7a240312b533d6122558085a">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_infer_runtime_common_8h.html#aea2f543a9fc0e52fe4ae712920fd1247">cudaEvent_t</a> *&#160;</td>
          <td class="paramname"><em>inputConsumed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously execute inference. </p>
<p>This method requires an array of input and output buffers. The mapping from tensor names to indices can be queried using <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">ICudaEngine::getBindingIndex()</a>. This method only works for execution contexts built with full dimension networks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindings</td><td>An array of pointers to input and output buffers for the network. </td></tr>
    <tr><td class="paramname">stream</td><td>A cuda stream on which the inference kernels will be enqueued </td></tr>
    <tr><td class="paramname">inputConsumed</td><td>An optional event which will be signaled when the input buffers can be refilled with new data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the kernels were enqueued successfully.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">ICudaEngine::getBindingIndex()</a> <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a08eeca149f7e2ad8b9ebbf03982396e0" title="Get the maximum batch size which can be used for inference. ">ICudaEngine::getMaxBatchSize()</a> </dd></dl>

</div>
</div>
<a id="a1fba6d417077b30a270d623119d02731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fba6d417077b30a270d623119d02731">&#9670;&nbsp;</a></span>execute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::IExecutionContext::execute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>batchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>bindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously execute inference on a batch. </p>
<p>This method requires an array of input and output buffers. The mapping from tensor names to indices can be queried using <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">ICudaEngine::getBindingIndex()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batchSize</td><td>The batch size. This is at most the value supplied when the engine was built. </td></tr>
    <tr><td class="paramname">bindings</td><td>An array of pointers to input and output buffers for the network.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if execution succeeded.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">ICudaEngine::getBindingIndex()</a> <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a08eeca149f7e2ad8b9ebbf03982396e0" title="Get the maximum batch size which can be used for inference. ">ICudaEngine::getMaxBatchSize()</a> </dd></dl>

</div>
</div>
<a id="a4baca5d4e8642905d487aaf7ca01c5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4baca5d4e8642905d487aaf7ca01c5ea">&#9670;&nbsp;</a></span>executeV2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::IExecutionContext::executeV2 </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>bindings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously execute inference a network. </p>
<p>This method requires an array of input and output buffers. The mapping from tensor names to indices can be queried using <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">ICudaEngine::getBindingIndex()</a>. This method only works for execution contexts built with full dimension networks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindings</td><td>An array of pointers to input and output buffers for the network.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if execution succeeded.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a6e5af99189eaba37f07509d466b90ba8" title="Retrieve the binding index for a named tensor. ">ICudaEngine::getBindingIndex()</a> <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a08eeca149f7e2ad8b9ebbf03982396e0" title="Get the maximum batch size which can be used for inference. ">ICudaEngine::getMaxBatchSize()</a> </dd></dl>

</div>
</div>
<a id="af915b83bfe8f5f8c02115f4a85e418ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af915b83bfe8f5f8c02115f4a85e418ca">&#9670;&nbsp;</a></span>getBindingDimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnvinfer1_1_1_dims.html">Dims</a> nvinfer1::IExecutionContext::getBindingDimensions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dynamic dimensions of a binding. </p>
<p>If the engine was built with an implicit batch dimension, same as <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#ac19759f11fd339cb6f84e37433bb02de" title="Get the dimensions of a binding. ">ICudaEngine::getBindingDimensions</a>.</p>
<p>If <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a9f87003474bc387e17782292cc2ea613" title="Set the dynamic dimensions of a binding. ">setBindingDimensions()</a> has been called on this binding (or if there are no dynamic dimensions), all dimensions will be positive. Otherwise, it is necessary to call <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a9f87003474bc387e17782292cc2ea613" title="Set the dynamic dimensions of a binding. ">setBindingDimensions()</a> before <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a84436f784eb3f0ea9089de2678d77954" title="Asynchronously execute inference on a batch. ">enqueue()</a> or <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a1fba6d417077b30a270d623119d02731" title="Synchronously execute inference on a batch. ">execute()</a> may be called.</p>
<p>If the bindingIndex is out of range, an invalid <a class="el" href="classnvinfer1_1_1_dims.html" title="Structure to define the dimensions of a tensor. ">Dims</a> with nbDims == -1 is returned. The same invalid <a class="el" href="classnvinfer1_1_1_dims.html" title="Structure to define the dimensions of a tensor. ">Dims</a> will be returned if the engine was not built with an implicit batch dimension and if the execution context is not currently associated with a valid optimization profile (i.e. if <a class="el" href="classnvinfer1_1_1_i_execution_context.html#abb6a76a642ee2f9619cf090947b7043e" title="Get the index of the currently selected optimization profile. ">getOptimizationProfile()</a> returns -1).</p>
<p>If ICudaEngine::bindingIsInput(bindingIndex) is false, then both <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a76a7d80b6536a2ae68ae5ad7f2843c67" title="Whether all dynamic dimensions of input tensors have been specified. ">allInputDimensionsSpecified()</a> and <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a80144d10e666ff6ba33222d4f7212fa1" title="Whether all input shape bindings have been specified. ">allInputShapesSpecified()</a> must be true before calling this method.</p>
<dl class="section return"><dt>Returns</dt><dd>Currently selected binding dimensions </dd></dl>

</div>
</div>
<a id="a79088a93559183b46765981c96ca9f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79088a93559183b46765981c96ca9f01">&#9670;&nbsp;</a></span>getDebugSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::IExecutionContext::getDebugSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the debug sync flag. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a5c0d31911cd4873ac364d1193cc42de7" title="Set the debug sync flag. ">setDebugSync()</a> </dd></dl>

</div>
</div>
<a id="aa7a1424c402db671befbcdb5eccb77d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a1424c402db671befbcdb5eccb77d2">&#9670;&nbsp;</a></span>getEngine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html">ICudaEngine</a>&amp; nvinfer1::IExecutionContext::getEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the associated engine. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html" title="An engine for executing inference on a built network, with functionally unsafe features. ">ICudaEngine</a> </dd></dl>

</div>
</div>
<a id="a020e0a5be09f9d87f7abc4d03d94e0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020e0a5be09f9d87f7abc4d03d94e0e6">&#9670;&nbsp;</a></span>getErrorRecorder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnvinfer1_1_1_i_error_recorder.html">IErrorRecorder</a>* nvinfer1::IExecutionContext::getErrorRecorder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the ErrorRecorder assigned to this interface. </p>
<p>Retrieves the assigned error recorder object for the given class. A default error recorder does not exist, so a nullptr will be returned if setErrorRecorder has not been called.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="classnvinfer1_1_1_i_error_recorder.html" title="Reference counted application-implemented error reporting interface for TensorRT objects. ">IErrorRecorder</a> object that has been registered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a728ba0406b1d20d3bec9bfd8bbcefd2e" title="Set the ErrorRecorder for this interface. ">setErrorRecorder</a> </dd></dl>

</div>
</div>
<a id="adb63dace49fab3c5dfae0f61167c0a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb63dace49fab3c5dfae0f61167c0a33">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* nvinfer1::IExecutionContext::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the name of the execution context. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_execution_context.html#ac43a687b8bf5e12cbb1fc340bf63b245" title="Set the name of the execution context. ">setName()</a> </dd></dl>

</div>
</div>
<a id="abb6a76a642ee2f9619cf090947b7043e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6a76a642ee2f9619cf090947b7043e">&#9670;&nbsp;</a></span>getOptimizationProfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nvinfer1::IExecutionContext::getOptimizationProfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of the currently selected optimization profile. </p>
<p>If the profile index has not been set yet (implicitly to 0 for the first execution context to be created, or explicitly for all subsequent contexts), an invalid value of -1 will be returned and all calls to <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a84436f784eb3f0ea9089de2678d77954" title="Asynchronously execute inference on a batch. ">enqueue()</a> or <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a1fba6d417077b30a270d623119d02731" title="Synchronously execute inference on a batch. ">execute()</a> will fail until a valid profile index has been set. </p>

</div>
</div>
<a id="a2600d03ec4703fb15071069ae4ff38f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2600d03ec4703fb15071069ae4ff38f6">&#9670;&nbsp;</a></span>getProfiler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnvinfer1_1_1_i_profiler.html">IProfiler</a>* nvinfer1::IExecutionContext::getProfiler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the profiler. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_profiler.html" title="Application-implemented interface for profiling. ">IProfiler</a> <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a0e72ed71fa265277b3bac4c1de765f1a" title="Set the profiler. ">setProfiler()</a> </dd></dl>

</div>
</div>
<a id="a3afb239c59299f5e88a617781d294d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afb239c59299f5e88a617781d294d44">&#9670;&nbsp;</a></span>getShapeBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::IExecutionContext::getShapeBinding </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get values of an input tensor required for shape calculations or an output tensor produced by shape calculations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>index of an input or output tensor for which ICudaEngine::isShapeBinding(bindingIndex) is true.</td></tr>
    <tr><td class="paramname">data</td><td>pointer to where values will be written. The number of values written is the product of the dimensions returned by getBindingDimensions(bindingIndex).</td></tr>
  </table>
  </dd>
</dl>
<p>If ICudaEngine::bindingIsInput(bindingIndex) is false, then both <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a76a7d80b6536a2ae68ae5ad7f2843c67" title="Whether all dynamic dimensions of input tensors have been specified. ">allInputDimensionsSpecified()</a> and <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a80144d10e666ff6ba33222d4f7212fa1" title="Whether all input shape bindings have been specified. ">allInputShapesSpecified()</a> must be true before calling this method. The method will also fail if no valid optimization profile has been set for the current execution context, i.e. if <a class="el" href="classnvinfer1_1_1_i_execution_context.html#abb6a76a642ee2f9619cf090947b7043e" title="Get the index of the currently selected optimization profile. ">getOptimizationProfile()</a> returns -1.</p>
<dl class="section see"><dt>See also</dt><dd>isShapeBinding(bindingIndex) </dd></dl>

</div>
</div>
<a id="a84ebf5bd5b925446296b1652cf63f4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ebf5bd5b925446296b1652cf63f4d8">&#9670;&nbsp;</a></span>getStrides()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnvinfer1_1_1_dims.html">Dims</a> nvinfer1::IExecutionContext::getStrides </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the strides of the buffer for the given binding. </p>
<p>Note that strides can be different for different execution contexts with dynamic shapes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>The binding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f87003474bc387e17782292cc2ea613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f87003474bc387e17782292cc2ea613">&#9670;&nbsp;</a></span>setBindingDimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::IExecutionContext::setBindingDimensions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnvinfer1_1_1_dims.html">Dims</a>&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the dynamic dimensions of a binding. </p>
<p>Requires the engine to be built without an implicit batch dimension. The binding must be an input tensor, and all dimensions must be compatible with the network definition (i.e. only the wildcard dimension -1 can be replaced with a new dimension &gt; 0). Furthermore, the dimensions must be in the valid range for the currently selected optimization profile, and the corresponding engine must not be safety-certified. This method will fail unless a valid optimization profile is defined for the current execution context (<a class="el" href="classnvinfer1_1_1_i_execution_context.html#abb6a76a642ee2f9619cf090947b7043e" title="Get the index of the currently selected optimization profile. ">getOptimizationProfile()</a> must not be -1).</p>
<p>For all dynamic non-output bindings (which have at least one wildcard dimension of -1), this method needs to be called before either <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a84436f784eb3f0ea9089de2678d77954" title="Asynchronously execute inference on a batch. ">enqueue()</a> or <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a1fba6d417077b30a270d623119d02731" title="Synchronously execute inference on a batch. ">execute()</a> may be called. This can be checked using the method <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a76a7d80b6536a2ae68ae5ad7f2843c67" title="Whether all dynamic dimensions of input tensors have been specified. ">allInputDimensionsSpecified()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>false if an error occurs (e.g. index out of range), else true </dd></dl>

</div>
</div>
<a id="a5c0d31911cd4873ac364d1193cc42de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0d31911cd4873ac364d1193cc42de7">&#9670;&nbsp;</a></span>setDebugSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvinfer1::IExecutionContext::setDebugSync </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the debug sync flag. </p>
<p>If this flag is set to true, the engine will log the successful execution for each kernel during <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a1fba6d417077b30a270d623119d02731" title="Synchronously execute inference on a batch. ">execute()</a>. It has no effect when using <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a84436f784eb3f0ea9089de2678d77954" title="Asynchronously execute inference on a batch. ">enqueue()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a79088a93559183b46765981c96ca9f01" title="Get the debug sync flag. ">getDebugSync()</a> </dd></dl>

</div>
</div>
<a id="a952c957725cd9ea5044087b523c480d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952c957725cd9ea5044087b523c480d2">&#9670;&nbsp;</a></span>setDeviceMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvinfer1::IExecutionContext::setDeviceMemory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the device memory for use by this execution context. </p>
<p>The memory must be aligned with cuda memory alignment property (using cudaGetDeviceProperties()), and its size must be at least that returned by getDeviceMemorySize(). If using <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a84436f784eb3f0ea9089de2678d77954" title="Asynchronously execute inference on a batch. ">enqueue()</a> to run the network, The memory is in use from the invocation of <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a84436f784eb3f0ea9089de2678d77954" title="Asynchronously execute inference on a batch. ">enqueue()</a> until network execution is complete. If using <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a1fba6d417077b30a270d623119d02731" title="Synchronously execute inference on a batch. ">execute()</a>, it is in use until <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a1fba6d417077b30a270d623119d02731" title="Synchronously execute inference on a batch. ">execute()</a> returns. Releasing or otherwise using the memory for other purposes during this time will result in undefined behavior.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a22de1c46f94f59e88d33ef0330be4069" title="Return the amount of device memory required by an execution context. ">ICudaEngine::getDeviceMemorySize()</a> <a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a773f668a04e6d9aa6b2ac1a02c37f251" title="create an execution context without any device memory allocated ">ICudaEngine::createExecutionContextWithoutDeviceMemory()</a> </dd></dl>

</div>
</div>
<a id="a728ba0406b1d20d3bec9bfd8bbcefd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728ba0406b1d20d3bec9bfd8bbcefd2e">&#9670;&nbsp;</a></span>setErrorRecorder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvinfer1::IExecutionContext::setErrorRecorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvinfer1_1_1_i_error_recorder.html">IErrorRecorder</a> *&#160;</td>
          <td class="paramname"><em>recorder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the ErrorRecorder for this interface. </p>
<p>Assigns the ErrorRecorder to this interface. The ErrorRecorder will track all errors during execution. This function will call incRefCount of the registered ErrorRecorder at least once. Setting recorder to nullptr unregisters the recorder with the interface, resulting in a call to decRefCount if a recorder has been registered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recorder</td><td>The error recorder to register with this interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_execution_context.html#a020e0a5be09f9d87f7abc4d03d94e0e6" title="get the ErrorRecorder assigned to this interface. ">getErrorRecorder</a> </dd></dl>

</div>
</div>
<a id="a306a7c94521d6a211be715ceb07c8c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306a7c94521d6a211be715ceb07c8c80">&#9670;&nbsp;</a></span>setInputShapeBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::IExecutionContext::setInputShapeBinding </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bindingIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set values of input tensor required by shape calculations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingIndex</td><td>index of an input tensor for which ICudaEngine::isShapeBinding(bindingIndex) and ICudaEngine::bindingIsInput(bindingIndex) are both true.</td></tr>
    <tr><td class="paramname">data</td><td>pointer to values of the input tensor. The number of values should be the product of the dimensions returned by getBindingDimensions(bindingIndex).</td></tr>
  </table>
  </dd>
</dl>
<p>If ICudaEngine::isShapeBinding(bindingIndex) and ICudaEngine::bindingIsInput(bindingIndex) are both true, this method must be called before <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a84436f784eb3f0ea9089de2678d77954" title="Asynchronously execute inference on a batch. ">enqueue()</a> or <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a1fba6d417077b30a270d623119d02731" title="Synchronously execute inference on a batch. ">execute()</a> may be called. This method will fail unless a valid optimization profile is defined for the current execution context (<a class="el" href="classnvinfer1_1_1_i_execution_context.html#abb6a76a642ee2f9619cf090947b7043e" title="Get the index of the currently selected optimization profile. ">getOptimizationProfile()</a> must not be -1). </p>

</div>
</div>
<a id="ac43a687b8bf5e12cbb1fc340bf63b245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43a687b8bf5e12cbb1fc340bf63b245">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvinfer1::IExecutionContext::setName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the name of the execution context. </p>
<p>This method copies the name string.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_execution_context.html#adb63dace49fab3c5dfae0f61167c0a33" title="Return the name of the execution context. ">getName()</a> </dd></dl>

</div>
</div>
<a id="aba0731b9fbc926c477010df818650b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0731b9fbc926c477010df818650b0a">&#9670;&nbsp;</a></span>setOptimizationProfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvinfer1::IExecutionContext::setOptimizationProfile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profileIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an optimization profile for the current context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileIndex</td><td>Index of the profile. It must lie between 0 and <a class="el" href="classnvinfer1_1_1_i_execution_context.html#aa7a1424c402db671befbcdb5eccb77d2" title="Get the associated engine. ">getEngine()</a>.getNbOptimizationProfiles() - 1</td></tr>
  </table>
  </dd>
</dl>
<p>The selected profile will be used in subsequent calls to <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a1fba6d417077b30a270d623119d02731" title="Synchronously execute inference on a batch. ">execute()</a> or <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a84436f784eb3f0ea9089de2678d77954" title="Asynchronously execute inference on a batch. ">enqueue()</a>.</p>
<p>If the associated CUDA engine has dynamic inputs, this method must be called exactly once with a unique profileIndex before calling execute or enqueue (i.e. the profile index may not be in use by another execution context that has not been destroyed yet). Once the optimization profile has been set (<a class="el" href="classnvinfer1_1_1_i_execution_context.html#abb6a76a642ee2f9619cf090947b7043e" title="Get the index of the currently selected optimization profile. ">getOptimizationProfile()</a> != -1), it cannot be changed. For the first execution context that is created for an engine, setOptimizationProfile(0) is called implicitly. This means users only ever need to call this method if they need more than a single execution context. In this case, profileIdx must be nonzero and unique for all execution contexts that are created after the first.</p>
<p>If the associated CUDA engine has not dynamic inputs, this method need not be called, in which case the default profile index of 0 will be used (this is particularly the case for all safe engines).</p>
<p><a class="el" href="classnvinfer1_1_1_i_execution_context.html#aba0731b9fbc926c477010df818650b0a" title="Select an optimization profile for the current context. ">setOptimizationProfile()</a> must be called before calling <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a9f87003474bc387e17782292cc2ea613" title="Set the dynamic dimensions of a binding. ">setBindingDimensions()</a> and <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a306a7c94521d6a211be715ceb07c8c80" title="Set values of input tensor required by shape calculations. ">setInputShapeBinding()</a> for all dynamic input tensors or input shape tensors, which in turn must be called before either <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a1fba6d417077b30a270d623119d02731" title="Synchronously execute inference on a batch. ">execute()</a> or <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a84436f784eb3f0ea9089de2678d77954" title="Asynchronously execute inference on a batch. ">enqueue()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the call succeeded, else false (e.g. input out of range)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_cuda_engine.html#a4dd0a5145a5f59bdafa0dac3c76031c3" title="Get the number of optimization profiles defined for this engine. ">ICudaEngine::getNbOptimizationProfiles()</a> </dd></dl>

</div>
</div>
<a id="a0e72ed71fa265277b3bac4c1de765f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e72ed71fa265277b3bac4c1de765f1a">&#9670;&nbsp;</a></span>setProfiler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvinfer1::IExecutionContext::setProfiler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvinfer1_1_1_i_profiler.html">IProfiler</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the profiler. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnvinfer1_1_1_i_profiler.html" title="Application-implemented interface for profiling. ">IProfiler</a> <a class="el" href="classnvinfer1_1_1_i_execution_context.html#a2600d03ec4703fb15071069ae4ff38f6" title="Get the profiler. ">getProfiler()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_nv_infer_runtime_8h_source.html">NvInferRuntime.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenvinfer1.html">nvinfer1</a></li><li class="navelem"><a class="el" href="classnvinfer1_1_1_i_execution_context.html">IExecutionContext</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
